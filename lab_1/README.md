## main_old.c - старая версия без создания нового потока
## main_thr.c - новая версия с потоком для обработки сигналов

```
Запустить демона без прав суперюзера:
    ./oslabd
Запустить демона с правами суперюзера:
    sudo ./oslabd
Найти демона в списке процессов (запомнить pid):
    ps -axj
Посмотреть log:
    tail -n 100 /var/log/syslog
Посмотреть номера сигналов:
    kill -l
Отправить SIGHUP:
    sudo kill -1 %pid%
Отправить SIGTERM:
    sudo kill -15 %pid%
```
# Вопросы
## Вопросы по ps -axj
Флаги для вывода:
- a - процессы, которыми владеют другие пользователи;
- x - процессы, которые не имеют управляющего терминала (TTY);
- j - вывод дополнительных сведений о процессах.

Идентификаторы:
- PPID - идентификатор процесса-родителя;
- PID (process id) = PGID (process group) = SID (session id);
- TTY - имя терминала;
- TPGID - идентификатор группы процессов терминала, к которому подключен процесс (-1) если нет терминала;
- STAT - состояние процесса;
    Состояния:
    - S - interruptable sleep;
    - D - uninterruptable sleep (I/O);
    - I - работа в режиме ядра.
    Доп:
    - s - лидер сессии;
    - l - многопоточный.
 - TIME - время запуска процесса;
 - COMMAND - название команды, запустившей процесс (вроде).
 
У демона PID = PGID = SID, т.к. у него не должно быть управляющего терминала, и он не должен получать сигналов от процессов из своей группы/сессии.
 
## Что делает already_running()?
Для обеспечения работы демона в единственном экземпляре. Осуществляется блокировкой файла в области ядра ОС, пока один процесс "держит" блокировку, другой заблокировать файл не сможет

## Почему демон должен работать в единственном экземпляре?
Демон предоставляет сервис. Не нужно предоставлять одни и те же услуги.

## Порядок действий в daemonize

## Почему нужно запускать с правами суперпользователя?
Демона нужно запускать с правами суперпользователя, чтобы можно было создать файл в области ядра ОС для обеспечения работы демона в единственном экземпляре.
